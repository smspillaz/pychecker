This is a re-write of pychecker using traditional parse tree
techniques, rather than the bytecode.

There are some other design changes, related to Warning objects and
Option handling.  In general, pychecker2 tries to distribute checks to
separate classes.  These classes are more self-contained: they hold
onto the option variables and define the Warning objects they support.

ToDo:
        All missing stuff
        Always returning None

Items still missing:
        Error suppression (errors may be suppressed globally)

        Member not used
        Return value from __init__
        Wrong # of args on function (including ctor)
        Member not initialized in __init__
        Function arguments, kwargs
        Not calling base class __init__
        Explicit/implicit returns
        Abstract methods
        constant in conditional
        Define None
        Detail of exception is an exception
        Local used after deleted, already deleted, deleted before set
        Using `self` in __repr__
        Using return value which is always None
        locals() should use locals
        globals() should use globals
        exec may use locals/globals

        Modifying a default parameter
        Tuple access to list list[1, 2]
        List .append() takes one argument
        Return None from __getattr__
        string iteration
        Inconsistent return type
        Object has no attr
        Method read as attribute, but not called:
        Function always returns None (use empty return)
        Unpack wrong size
        Unpack wrong type

        Exec warnings
        Security warning: input()

        No __init__ in subclass
        Module imports itself
        Complexity
        Doc strings
        New python features:
             slots
             properties
             integer division
        Warning for string raising

Bugs:
        Speed
        Is __file__ a builtin?

        Aliases:
            class C:
                  def f(a, b): pass
                  def g(a, b): pass
                  h = f
                  h = g			# redef of h, not caught now

        foo = 1
        del foo	                        # should not be unused

        from __future__ import produces unused warnings
        import of readline has side effect on input/raw_input, and should be
           marked as used

Important stuff:

If you want to add new checks, there are some parts to be aware of:

        File
                A stupid data structure to hold everything we know about 
                a file to be checked.

                Members:
                   name
                        The file name.

                   parseTree
                        The root of the Abstract Syntax Tree returned from
                        compiler.parseFile.  Will be None if the file
                        won't even parse.

                   scopes
                        A dictionary of { node, scope } computed with
                        from compiler.symbols. For convenience, scopes
                        also refer back to the node and to the
                        enclosing parent scope (node and parent,
                        respectively).

                    root_scope
                        Convience for scopes[parseTree]

        Check
                Basic step for checking a file.  Usually contributes
                Warnings or additional information to File.  New checks
                will subclass this, and be added to the chain of checks
                given in main().

        Warning
                A description of a warning emitted by pychecker.

        CheckList
                Contains "global" check information: cached module
                data and the list of Check objects.

        Command line options are pulled from each check.
        A Warning is also turned into a boolean-style command line option.

